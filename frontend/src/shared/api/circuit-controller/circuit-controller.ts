/**
 * Generated by orval v7.21.0 ðŸº
 * Do not edit manually.
 * Tarikma API
 * Backend API for Tarik.ma
 * OpenAPI spec version: v1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AddCircuitStopRequest,
  AiGenerateCircuitRequest,
  AiSuggestPlacesRequest,
  CircuitPlanningWarningResponse,
  CircuitResponse,
  CircuitSessionResponse,
  CircuitSummaryResponse,
  CreateCircuitRequest,
  CreateCircuitSessionRequest,
  ListMyCircuitsParams,
  UpdateCircuitRequest,
  UpdateCircuitSessionRequest,
  UpdateCircuitStopRequest,
  UpsertCircuitRouteRequest
} from '.././model';

import { customInstance } from '.././orval-mutator';




export const getMyCircuit = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CircuitResponse>(
      {url: `/api/circuits/${id}`, method: 'GET', signal
    },
      );
    }
  



export const getGetMyCircuitQueryKey = (id?: number,) => {
    return [
    `/api/circuits/${id}`
    ] as const;
    }

    
export const getGetMyCircuitQueryOptions = <TData = Awaited<ReturnType<typeof getMyCircuit>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyCircuit>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyCircuitQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyCircuit>>> = ({ signal }) => getMyCircuit(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyCircuit>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMyCircuitQueryResult = NonNullable<Awaited<ReturnType<typeof getMyCircuit>>>
export type GetMyCircuitQueryError = unknown


export function useGetMyCircuit<TData = Awaited<ReturnType<typeof getMyCircuit>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyCircuit>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyCircuit>>,
          TError,
          Awaited<ReturnType<typeof getMyCircuit>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMyCircuit<TData = Awaited<ReturnType<typeof getMyCircuit>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyCircuit>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyCircuit>>,
          TError,
          Awaited<ReturnType<typeof getMyCircuit>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMyCircuit<TData = Awaited<ReturnType<typeof getMyCircuit>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyCircuit>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMyCircuit<TData = Awaited<ReturnType<typeof getMyCircuit>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyCircuit>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMyCircuitQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateCircuit = (
    id: number,
    updateCircuitRequest: UpdateCircuitRequest,
 ) => {
      
      
      return customInstance<CircuitResponse>(
      {url: `/api/circuits/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateCircuitRequest
    },
      );
    }
  


export const getUpdateCircuitMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCircuit>>, TError,{id: number;data: UpdateCircuitRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCircuit>>, TError,{id: number;data: UpdateCircuitRequest}, TContext> => {

const mutationKey = ['updateCircuit'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCircuit>>, {id: number;data: UpdateCircuitRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  updateCircuit(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCircuitMutationResult = NonNullable<Awaited<ReturnType<typeof updateCircuit>>>
    export type UpdateCircuitMutationBody = UpdateCircuitRequest
    export type UpdateCircuitMutationError = unknown

    export const useUpdateCircuit = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCircuit>>, TError,{id: number;data: UpdateCircuitRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCircuit>>,
        TError,
        {id: number;data: UpdateCircuitRequest},
        TContext
      > => {

      const mutationOptions = getUpdateCircuitMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const deleteCircuit = (
    id: number,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/circuits/${id}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCircuitMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCircuit>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCircuit>>, TError,{id: number}, TContext> => {

const mutationKey = ['deleteCircuit'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCircuit>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  deleteCircuit(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCircuitMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCircuit>>>
    
    export type DeleteCircuitMutationError = unknown

    export const useDeleteCircuit = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCircuit>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCircuit>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getDeleteCircuitMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const updateStop = (
    id: number,
    stopId: number,
    updateCircuitStopRequest: UpdateCircuitStopRequest,
 ) => {
      
      
      return customInstance<CircuitResponse>(
      {url: `/api/circuits/${id}/stops/${stopId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateCircuitStopRequest
    },
      );
    }
  


export const getUpdateStopMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateStop>>, TError,{id: number;stopId: number;data: UpdateCircuitStopRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateStop>>, TError,{id: number;stopId: number;data: UpdateCircuitStopRequest}, TContext> => {

const mutationKey = ['updateStop'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateStop>>, {id: number;stopId: number;data: UpdateCircuitStopRequest}> = (props) => {
          const {id,stopId,data} = props ?? {};

          return  updateStop(id,stopId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateStopMutationResult = NonNullable<Awaited<ReturnType<typeof updateStop>>>
    export type UpdateStopMutationBody = UpdateCircuitStopRequest
    export type UpdateStopMutationError = unknown

    export const useUpdateStop = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateStop>>, TError,{id: number;stopId: number;data: UpdateCircuitStopRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateStop>>,
        TError,
        {id: number;stopId: number;data: UpdateCircuitStopRequest},
        TContext
      > => {

      const mutationOptions = getUpdateStopMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const deleteStop = (
    id: number,
    stopId: number,
 ) => {
      
      
      return customInstance<CircuitResponse>(
      {url: `/api/circuits/${id}/stops/${stopId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteStopMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteStop>>, TError,{id: number;stopId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteStop>>, TError,{id: number;stopId: number}, TContext> => {

const mutationKey = ['deleteStop'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteStop>>, {id: number;stopId: number}> = (props) => {
          const {id,stopId} = props ?? {};

          return  deleteStop(id,stopId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteStopMutationResult = NonNullable<Awaited<ReturnType<typeof deleteStop>>>
    
    export type DeleteStopMutationError = unknown

    export const useDeleteStop = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteStop>>, TError,{id: number;stopId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteStop>>,
        TError,
        {id: number;stopId: number},
        TContext
      > => {

      const mutationOptions = getDeleteStopMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const updateSession = (
    id: number,
    sessionId: number,
    updateCircuitSessionRequest: UpdateCircuitSessionRequest,
 ) => {
      
      
      return customInstance<CircuitSessionResponse>(
      {url: `/api/circuits/${id}/sessions/${sessionId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateCircuitSessionRequest
    },
      );
    }
  


export const getUpdateSessionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{id: number;sessionId: number;data: UpdateCircuitSessionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{id: number;sessionId: number;data: UpdateCircuitSessionRequest}, TContext> => {

const mutationKey = ['updateSession'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSession>>, {id: number;sessionId: number;data: UpdateCircuitSessionRequest}> = (props) => {
          const {id,sessionId,data} = props ?? {};

          return  updateSession(id,sessionId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof updateSession>>>
    export type UpdateSessionMutationBody = UpdateCircuitSessionRequest
    export type UpdateSessionMutationError = unknown

    export const useUpdateSession = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{id: number;sessionId: number;data: UpdateCircuitSessionRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSession>>,
        TError,
        {id: number;sessionId: number;data: UpdateCircuitSessionRequest},
        TContext
      > => {

      const mutationOptions = getUpdateSessionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const deleteSession = (
    id: number,
    sessionId: number,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/circuits/${id}/sessions/${sessionId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteSessionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSession>>, TError,{id: number;sessionId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteSession>>, TError,{id: number;sessionId: number}, TContext> => {

const mutationKey = ['deleteSession'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSession>>, {id: number;sessionId: number}> = (props) => {
          const {id,sessionId} = props ?? {};

          return  deleteSession(id,sessionId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSessionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSession>>>
    
    export type DeleteSessionMutationError = unknown

    export const useDeleteSession = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSession>>, TError,{id: number;sessionId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSession>>,
        TError,
        {id: number;sessionId: number},
        TContext
      > => {

      const mutationOptions = getDeleteSessionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const upsertRoute = (
    id: number,
    upsertCircuitRouteRequest: UpsertCircuitRouteRequest,
 ) => {
      
      
      return customInstance<CircuitResponse>(
      {url: `/api/circuits/${id}/routes`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: upsertCircuitRouteRequest
    },
      );
    }
  


export const getUpsertRouteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof upsertRoute>>, TError,{id: number;data: UpsertCircuitRouteRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof upsertRoute>>, TError,{id: number;data: UpsertCircuitRouteRequest}, TContext> => {

const mutationKey = ['upsertRoute'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof upsertRoute>>, {id: number;data: UpsertCircuitRouteRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  upsertRoute(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpsertRouteMutationResult = NonNullable<Awaited<ReturnType<typeof upsertRoute>>>
    export type UpsertRouteMutationBody = UpsertCircuitRouteRequest
    export type UpsertRouteMutationError = unknown

    export const useUpsertRoute = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof upsertRoute>>, TError,{id: number;data: UpsertCircuitRouteRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof upsertRoute>>,
        TError,
        {id: number;data: UpsertCircuitRouteRequest},
        TContext
      > => {

      const mutationOptions = getUpsertRouteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const listMyCircuits = (
    params?: ListMyCircuitsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CircuitSummaryResponse[]>(
      {url: `/api/circuits`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListMyCircuitsQueryKey = (params?: ListMyCircuitsParams,) => {
    return [
    `/api/circuits`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListMyCircuitsQueryOptions = <TData = Awaited<ReturnType<typeof listMyCircuits>>, TError = unknown>(params?: ListMyCircuitsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMyCircuits>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListMyCircuitsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listMyCircuits>>> = ({ signal }) => listMyCircuits(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listMyCircuits>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListMyCircuitsQueryResult = NonNullable<Awaited<ReturnType<typeof listMyCircuits>>>
export type ListMyCircuitsQueryError = unknown


export function useListMyCircuits<TData = Awaited<ReturnType<typeof listMyCircuits>>, TError = unknown>(
 params: undefined |  ListMyCircuitsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMyCircuits>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listMyCircuits>>,
          TError,
          Awaited<ReturnType<typeof listMyCircuits>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListMyCircuits<TData = Awaited<ReturnType<typeof listMyCircuits>>, TError = unknown>(
 params?: ListMyCircuitsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMyCircuits>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listMyCircuits>>,
          TError,
          Awaited<ReturnType<typeof listMyCircuits>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListMyCircuits<TData = Awaited<ReturnType<typeof listMyCircuits>>, TError = unknown>(
 params?: ListMyCircuitsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMyCircuits>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useListMyCircuits<TData = Awaited<ReturnType<typeof listMyCircuits>>, TError = unknown>(
 params?: ListMyCircuitsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMyCircuits>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListMyCircuitsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const createCircuit = (
    createCircuitRequest: CreateCircuitRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CircuitResponse>(
      {url: `/api/circuits`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createCircuitRequest, signal
    },
      );
    }
  


export const getCreateCircuitMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCircuit>>, TError,{data: CreateCircuitRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCircuit>>, TError,{data: CreateCircuitRequest}, TContext> => {

const mutationKey = ['createCircuit'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCircuit>>, {data: CreateCircuitRequest}> = (props) => {
          const {data} = props ?? {};

          return  createCircuit(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCircuitMutationResult = NonNullable<Awaited<ReturnType<typeof createCircuit>>>
    export type CreateCircuitMutationBody = CreateCircuitRequest
    export type CreateCircuitMutationError = unknown

    export const useCreateCircuit = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCircuit>>, TError,{data: CreateCircuitRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCircuit>>,
        TError,
        {data: CreateCircuitRequest},
        TContext
      > => {

      const mutationOptions = getCreateCircuitMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const addStop = (
    id: number,
    addCircuitStopRequest: AddCircuitStopRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CircuitResponse>(
      {url: `/api/circuits/${id}/stops`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addCircuitStopRequest, signal
    },
      );
    }
  


export const getAddStopMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addStop>>, TError,{id: number;data: AddCircuitStopRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addStop>>, TError,{id: number;data: AddCircuitStopRequest}, TContext> => {

const mutationKey = ['addStop'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addStop>>, {id: number;data: AddCircuitStopRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  addStop(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddStopMutationResult = NonNullable<Awaited<ReturnType<typeof addStop>>>
    export type AddStopMutationBody = AddCircuitStopRequest
    export type AddStopMutationError = unknown

    export const useAddStop = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addStop>>, TError,{id: number;data: AddCircuitStopRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addStop>>,
        TError,
        {id: number;data: AddCircuitStopRequest},
        TContext
      > => {

      const mutationOptions = getAddStopMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const listSessions = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CircuitSessionResponse[]>(
      {url: `/api/circuits/${id}/sessions`, method: 'GET', signal
    },
      );
    }
  



export const getListSessionsQueryKey = (id?: number,) => {
    return [
    `/api/circuits/${id}/sessions`
    ] as const;
    }

    
export const getListSessionsQueryOptions = <TData = Awaited<ReturnType<typeof listSessions>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSessions>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListSessionsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listSessions>>> = ({ signal }) => listSessions(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listSessions>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListSessionsQueryResult = NonNullable<Awaited<ReturnType<typeof listSessions>>>
export type ListSessionsQueryError = unknown


export function useListSessions<TData = Awaited<ReturnType<typeof listSessions>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSessions>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSessions>>,
          TError,
          Awaited<ReturnType<typeof listSessions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListSessions<TData = Awaited<ReturnType<typeof listSessions>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSessions>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSessions>>,
          TError,
          Awaited<ReturnType<typeof listSessions>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListSessions<TData = Awaited<ReturnType<typeof listSessions>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSessions>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useListSessions<TData = Awaited<ReturnType<typeof listSessions>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSessions>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListSessionsQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const createSession = (
    id: number,
    createCircuitSessionRequest: CreateCircuitSessionRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CircuitSessionResponse>(
      {url: `/api/circuits/${id}/sessions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createCircuitSessionRequest, signal
    },
      );
    }
  


export const getCreateSessionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{id: number;data: CreateCircuitSessionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{id: number;data: CreateCircuitSessionRequest}, TContext> => {

const mutationKey = ['createSession'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSession>>, {id: number;data: CreateCircuitSessionRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  createSession(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof createSession>>>
    export type CreateSessionMutationBody = CreateCircuitSessionRequest
    export type CreateSessionMutationError = unknown

    export const useCreateSession = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{id: number;data: CreateCircuitSessionRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSession>>,
        TError,
        {id: number;data: CreateCircuitSessionRequest},
        TContext
      > => {

      const mutationOptions = getCreateSessionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const aiSuggestPlaces = (
    id: number,
    aiSuggestPlacesRequest: AiSuggestPlacesRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CircuitResponse>(
      {url: `/api/circuits/${id}/ai-suggest-places`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: aiSuggestPlacesRequest, signal
    },
      );
    }
  


export const getAiSuggestPlacesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof aiSuggestPlaces>>, TError,{id: number;data: AiSuggestPlacesRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof aiSuggestPlaces>>, TError,{id: number;data: AiSuggestPlacesRequest}, TContext> => {

const mutationKey = ['aiSuggestPlaces'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof aiSuggestPlaces>>, {id: number;data: AiSuggestPlacesRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  aiSuggestPlaces(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AiSuggestPlacesMutationResult = NonNullable<Awaited<ReturnType<typeof aiSuggestPlaces>>>
    export type AiSuggestPlacesMutationBody = AiSuggestPlacesRequest
    export type AiSuggestPlacesMutationError = unknown

    export const useAiSuggestPlaces = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof aiSuggestPlaces>>, TError,{id: number;data: AiSuggestPlacesRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof aiSuggestPlaces>>,
        TError,
        {id: number;data: AiSuggestPlacesRequest},
        TContext
      > => {

      const mutationOptions = getAiSuggestPlacesMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const aiReorderStops = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CircuitResponse>(
      {url: `/api/circuits/${id}/ai-reorder`, method: 'POST', signal
    },
      );
    }
  


export const getAiReorderStopsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof aiReorderStops>>, TError,{id: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof aiReorderStops>>, TError,{id: number}, TContext> => {

const mutationKey = ['aiReorderStops'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof aiReorderStops>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  aiReorderStops(id,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AiReorderStopsMutationResult = NonNullable<Awaited<ReturnType<typeof aiReorderStops>>>
    
    export type AiReorderStopsMutationError = unknown

    export const useAiReorderStops = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof aiReorderStops>>, TError,{id: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof aiReorderStops>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getAiReorderStopsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const aiGenerateCircuit = (
    aiGenerateCircuitRequest: AiGenerateCircuitRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CircuitResponse>(
      {url: `/api/circuits/ai-generate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: aiGenerateCircuitRequest, signal
    },
      );
    }
  


export const getAiGenerateCircuitMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof aiGenerateCircuit>>, TError,{data: AiGenerateCircuitRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof aiGenerateCircuit>>, TError,{data: AiGenerateCircuitRequest}, TContext> => {

const mutationKey = ['aiGenerateCircuit'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof aiGenerateCircuit>>, {data: AiGenerateCircuitRequest}> = (props) => {
          const {data} = props ?? {};

          return  aiGenerateCircuit(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AiGenerateCircuitMutationResult = NonNullable<Awaited<ReturnType<typeof aiGenerateCircuit>>>
    export type AiGenerateCircuitMutationBody = AiGenerateCircuitRequest
    export type AiGenerateCircuitMutationError = unknown

    export const useAiGenerateCircuit = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof aiGenerateCircuit>>, TError,{data: AiGenerateCircuitRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof aiGenerateCircuit>>,
        TError,
        {data: AiGenerateCircuitRequest},
        TContext
      > => {

      const mutationOptions = getAiGenerateCircuitMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export const getMyCircuitPlanningWarnings = (
    id: number,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CircuitPlanningWarningResponse[]>(
      {url: `/api/circuits/${id}/planning-warnings`, method: 'GET', signal
    },
      );
    }
  



export const getGetMyCircuitPlanningWarningsQueryKey = (id?: number,) => {
    return [
    `/api/circuits/${id}/planning-warnings`
    ] as const;
    }

    
export const getGetMyCircuitPlanningWarningsQueryOptions = <TData = Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>, TError = unknown>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyCircuitPlanningWarningsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>> = ({ signal }) => getMyCircuitPlanningWarnings(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetMyCircuitPlanningWarningsQueryResult = NonNullable<Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>>
export type GetMyCircuitPlanningWarningsQueryError = unknown


export function useGetMyCircuitPlanningWarnings<TData = Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>, TError = unknown>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>,
          TError,
          Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMyCircuitPlanningWarnings<TData = Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>,
          TError,
          Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetMyCircuitPlanningWarnings<TData = Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetMyCircuitPlanningWarnings<TData = Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>, TError = unknown>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyCircuitPlanningWarnings>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetMyCircuitPlanningWarningsQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




